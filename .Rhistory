for(s in c(1:ncol(DES))){ ## 4 hypotheses for spatial groupings
nStrata <- length(unique(DES[,s]))
data <-
list(
Length_cm = all_data[,"Length_cm"],
Age = all_data[,"Age"],
DES = as.vector(DES[,s]),
nStrata = nStrata
)
parameters <-
list(
log_Linf = rep(log(70), nStrata),
log_k = rep(log(0.5), nStrata),
t0 = rep(0, nStrata),
log_Sigma = 0
)
# Now estimate everything
map <- NULL
model <- MakeADFun(data, parameters,  DLL="sptlvb",silent=T,map=map)
fit <- nlminb(
model$par,
model$fn,
model$gr,
control = list(
rel.tol = 1e-12,
eval.max = 100000,
iter.max = 10000
)
)
# for (k in 1:3)  fit <- nlminb(model$env$last.par.best, model$fn, model$gr) ## start at last-best call, for stability
best <- model$env$last.par.best
rep <- sdreport(model)
dat0 <- c(dat0, model$report()$ypreds %>% data.frame()) ## each 6 cols is new sim
rep0 <- bind_rows(rep0, bind_cols(data.frame(names(rep$value)),data.frame(rep$value),data.frame(rep$sd),data.frame(c(rep(unique(KEY[,s]),3), rep("ALL",1)))))
aic0 <- c(aic0, model$report()$aic %>% data.frame())
}
## reformat outputs ----
## AIC and Weights
aic <- aic0 %>% data.frame()
names(aic) <- c('Pooled','3 Zone', 'Lit', 'Survey Strata')
aic[which.min(aic)]
relLike <- -0.5 * aic-min(aic)
aicweight <- relLike/sum(relLike)
aicweight
aicweight[which.max(aicweight)]
rm(list = ls)
rm(list = ls())
require(mgcv); require(dplyr); require(reshape); require(RColorBrewer); require(ggplot2)
library(ggsidekick)
## load and cbind data
setwd("C:/Users/mkapur/Dropbox/UW/sab-growth")
load( paste0(getwd(),"/data/gam_data.rda")) ## all_data
# all_data$Year <- as.factor(all_data$Year)
all_data$Year <- as.numeric(as.character(all_data$Year))
all_data$Sex <- as.factor(all_data$Sex)
all_data$Longitude_dd <- with(all_data, ifelse(Longitude_dd> 0, -1*Longitude_dd,Longitude_dd))
## change point gam in par est
## first fit with year only and check ACF
mod <- gam(Length_cm ~ s(Year, bs = "cc"), data = all_data)
# mod <- lm(Length_cm ~ Year, data = all_data)
acf(resid(mod),  main = "ACF")
mod <- gam(Length_cm ~ Age + Sex + s(Year, bs = "cc") + s(Latitude_dd,Longitude_dd),
data = all_data)
summary(mod)
## plotting model
mod2 <- gam(Length_cm ~ Age + Sex + s(Year, bs = "cc") +
s(Longitude_dd,Latitude_dd),
correlation = corAR1(form = ~ 1|Year, p = 2),
data = all_data)
# MuMIn::model.sel(mod,mod1,mod2,mod3)
save(mod2, paste0(getwd(),'spatial_gam.rdata'))
# MuMIn::model.sel(mod,mod1,mod2,mod3)
save(mod2, paste0(getwd(),'/spatial_gam.rdata'))
paste0(getwd(),'/spatial_gam.rdata')
# MuMIn::model.sel(mod,mod1,mod2,mod3)
save(mod2, paste0(getwd(),'/spatial_gam.rData'))
# MuMIn::model.sel(mod,mod1,mod2,mod3)
save(mod2, paste0(getwd(),'/spatial_gam.rda'))
# MuMIn::model.sel(mod,mod1,mod2,mod3)
save(mod2, file = paste0(getwd(),'/spatial_gam.rda'))
load(paste0(getwd(),'/spatial_gam.rda'))
rm(mod)
rm(mod2)
load(paste0(getwd(),'/spatial_gam.rda'))
plot.Deriv(m2.d, term = 'Latitude_dd', cex.axis = 2, main = 'derivative of latitude')
## source from gist
source(paste0(getwd(),"/Deriv.R"))
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year",c("Longitude_dd","Latitude_dd"))[2]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
## identify where CI does NOT include zero (return NA where it does)
m2.dsig <- signifD(pdat$predLen, d = m2.d[[Term]]$deriv, m2.dci[[Term]]$upper, m2.dci[[Term]]$lower)
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
s =1
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year",c("Longitude_dd","Latitude_dd"))[2]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
## identify where CI does NOT include zero (return NA where it does)
m2.dsig <- signifD(pdat$predLen, d = m2.d[[Term]]$deriv, m2.dci[[Term]]$upper, m2.dci[[Term]]$lower)
m2.dsig
llsmooth <- mod2$smooth[2][[1]]
llsmooth$knots
## calc first derivatives
pdat <- sample_n(all_data,1000)
pTerm <- predict(mod2, newdata = pdat, type = "terms", se.fit = TRUE)
p2 <- predict(mod2, newdata = pdat) ## raw predicts
pdat <- transform(pdat, predLen = p2, se2_spt = pTerm$se.fit[,4], se2_yr = pTerm$se.fit[,3])
df.res <- df.residual(mod2)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
## variances are additive just FYI
pdat <- transform(pdat,
upper = predLen + (crit.t * (se2_spt+se2_yr)),
lower = predLen - (crit.t * (se2_spt+se2_yr)))
## source from gist
m2.d
## identify where CI does NOT include zero (return NA where it does)
m2.dsig <- signifD(pdat$predLen, d = m2.d[[Term]]$deriv, m2.dci[[Term]]$upper, m2.dci[[Term]]$lower)
m2.dsig
unique(all_data$Year)
which(!is.na(m2.dsig$incr))
c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr))
)
which(!is.na(m2.dsig$decr))
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
newD[pix,]
str(m2.d)
str(m2.dsig)
dim(m2.d[[Term]])
dim(m2.d[[Term]]$deriv)
m2.d[[Year]]
m2.d[[Term]]
Term
m2.d
m2.d$eval[[Term]]
## identify where CI does NOT include zero (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]], d = m2.d[[Term]]$deriv, m2.dci[[Term]]$upper, m2.dci[[Term]]$lower)
m2.dsig
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
m2.d$eval[[Term]][pix]
Term <- c("Year",c("Longitude_dd","Latitude_dd"))[1]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
## identify where CI does NOT include zero (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]], d = m2.d[[Term]]$deriv, m2.dci[[Term]]$upper, m2.dci[[Term]]$lower)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
m2.d$eval[[Term]][pix]
vals <- m2.d$eval[[Term]][pix]
round(vals)
unique(round(vals))
m2.d[[Term]]
m2.d[[Term]]$deriv
crit.eval = mean(m2.d[[Term]]$deriv)
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
vals
round(vals)
unique(round(vals))
max(m2.d[[Term]]$deriv)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(0.95, m2.d[[Term]]$deriv)
m2.d[[Term]]$deriv
?quantile
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = 0.95, x=  m2.d[[Term]]$deriv)
crit.eval
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv)
crit.eval
signifD <- function(x, d, upper, lower, eval = 0) {
if(length(eval > 1)){
miss <- upper > eval[2] & lower < eval[1]
incr <- decr <- x
want <- d > eval
incr[!want | miss] <- NA
want <- d < eval
decr[!want | miss] <- NA
}
else{miss <- upper > eval & lower < eval
incr <- decr <- x
want <- d > eval
incr[!want | miss] <- NA
want <- d < eval
decr[!want | miss] <- NA
}
list(incr = incr, decr = decr)
}
crit.eval
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
pix
m2.d$eval[[Term]][pix]
m2.dsig
m2.dsig$incr
m2.dci[[Term]]
crit.eval
signifD <- function(x, d, upper, lower, eval = 0) {
if(length(eval > 1)){
miss <- upper > eval[1] & upper < eval[2]
incr <- decr <- x
want <- d > eval
incr[!want | miss] <- NA
want <- d < eval
decr[!want | miss] <- NA
}
else{miss <- upper > eval & lower < eval
incr <- decr <- x
want <- d > eval
incr[!want | miss] <- NA
want <- d < eval
decr[!want | miss] <- NA
}
list(incr = incr, decr = decr)
}
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
m2.dsig
m2.dsig$incr
m2.d[[Term]]$deriv
crit.eval
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
vals
round(vals)
unique(round(vals))
##iterate sex
breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
##iterate sex
breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
for(s in 1:2){
breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
if(t ==1) breaksdf[s,2] <- c(unique(round(vals)))
if(t ==2) breaksdf[s,3] <- c(unique(round(vals,3)))
}
}
vals
c(unique(round(vals)))
b <- list()
b[[1]]
b[[1]][2] <- 4
str(b)
b[1]
b[1][2]
b[1][2] <- 3
b[1] <- data.frame
b[1] <- data.frame()
##iterate sex
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
for(s in 1:2){
breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
breaksdf[[s]] <- c(unique(round(vals)))
}
}
##iterate sex
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
breaksdf[[s]] <- c(unique(round(vals)))
}
}
breaksdf
##iterate sex
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
idx <- 1
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
breaksdf[[idx]] <- c(unique(round(vals)))
idx <- idx+1
}
}
breaksdf
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
idx <- 1
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
breaksdf[[idx]] <- sort(c(unique(round(vals))))
idx <- idx+1
}
}
breaksdf
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1,33,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
breaksdf[[idx]] <- sort(c(unique(round(vals))))
cat(idx)
idx <- idx+1
}
}
breaksdf
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = 20, col = 'red')
min(all_data$Year)
head(all_data)
summary(all_data$Year)
##iterate sex
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
idx <- 1
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod2,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod2, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.05, 0.95), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix]
breaksdf[[idx]] <- sort(c(unique(round(vals))))
cat(idx)
idx <- idx+1
}
}
breaksdf
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
plot(mod2,  select  =2,  scheme  =2,  lwd  =2, main = '2d Spatial Smoother', cex.axis = 2)
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd', cex.axis = 2, main = 'derivative of latitude')
abline(h = breaksdf[[2]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd', cex.axis = 2, main = 'derivative of latitude')
abline(v = breaksdf[[2]], col = 'red')
layout(matrix(1:4, ncol = 2))
plot(mod2,  select  =1,  scheme  =2,  lwd  =2, main = 'Year Smoother', cex.axis = 2)
plot(mod2,  select  =2,  scheme  =2,  lwd  =2, main = '2d Spatial Smoother', cex.axis = 2)
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd', cex.axis
png( file = paste0(getwd(),"/plots/gam_smooths1.png"), height = 6, width = 8, units = 'in', res = 500)
layout(matrix(1:4, ncol = 2))
plot(mod2,  select  =1,  scheme  =2,  lwd  =2, main = 'Year Smoother', cex.axis = 2)
plot(mod2,  select  =2,  scheme  =2,  lwd  =2, main = '2d Spatial Smoother', cex.axis = 2)
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd', cex.axis = 2, main = 'derivative of latitude')
# abline(v = breaksdf[[2]], col = 'red')
dev.off()
png( file = paste0(getwd(),"/plots/gam_smooths.png"), height = 6, width = 8, units = 'in', res = 500)
layout(matrix(1:4, ncol = 2))
plot(mod2,  select  =1,  scheme  =2,  lwd  =2, main = 'Year Smoother', cex.axis = 2)
plot(mod2,  select  =2,  scheme  =2,  lwd  =2, main = '2d Spatial Smoother', cex.axis = 2)
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
# abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd', cex.axis = 2, main = 'derivative of latitude')
# abline(v = breaksdf[[2]], col = 'red')
dev.off()
