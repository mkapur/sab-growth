## parest by sex and region
parest <- read.csv("C:/Users/mkapur/Dropbox/UW/sab-growth/results/parEst_gam_2018-12-11.csv") %>%
filter(variable != "Sigma")
## exponentiate logk
parest[parest$variable == 'log_k','value'] <- exp(parest[parest$variable == 'log_k','value'] )
parest$variable <- ifelse(parest$variable=='log_k',"k",paste(parest$variable))
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~model+variable, scales = "free_y")
parest
dat0 <- rep0 <- NULL ## later storage
nStrata <- length(unique(DES))
data <-
list(
Length_cm = all_data[,"Length_cm"],
Age = all_data[,"Age"],
DES = as.vector(DES),
nStrata = nStrata
)
parameters <-
list(
log_Linf = rep(log(70), nStrata),
log_k = rep(log(0.5), nStrata),
t0 = rep(0, nStrata),
log_Sigma = 0
)
# Now estimate everything
map <- NULL
model <- MakeADFun(data, parameters,  DLL="sptlvb",silent=T,map=map)
fit <- nlminb(
model$par,
model$fn,
model$gr,
control = list(
rel.tol = 1e-12,
eval.max = 100000,
iter.max = 10000
)
)
# for (k in 1:3)  fit <- nlminb(model$env$last.par.best, model$fn, model$gr) ## start at last-best call, for stability
best <- model$env$last.par.best
rep <- sdreport(model)
dat0 <- c(dat0, model$report()$ypreds %>% data.frame()) ## each 6 cols is new sim
rep0 <- bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
data.frame(c(rep(unique(
KEY
), 3), rep("ALL", 1)))
))
rep0
## reformat outputs ----
names(rep0) <- c('variable', 'value','sd', 'ID')
rep0 <- rep0 %>% mutate(
st =sub('_([^_]*)$', '',  ID),
Sex = sub(".*_ *(._?)", "\\1", ID)
) %>% select(-ID)
rep0
## exponentiate logk
parest[parest$variable == 'log_k','value'] <- exp(parest[parest$variable == 'log_k','value'] )
parest$variable <- ifelse(parest$variable=='log_k',"k",paste(parest$variable))
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~model+variable, scales = "free_y")
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~st+variable, scales = "free_y")
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~variable, scales = "free_y")
ggsave(file = paste0(getwd(),"/plots/parplot_gam.png"),
plot = last_plot(), height = 6, width = 8, unit = 'in', dpi = 520)
parest
write.csv(rep0, paste0(getwd(),"/results/parEst_gam_",Sys.Date(),'.csv'),row.names = F)
## parest by sex and region
parest <- read.csv("C:/Users/mkapur/Dropbox/UW/sab-growth/results/parEst_gam_2018-12-11.csv") %>%
filter(variable != "Sigma")
## exponentiate logk
parest[parest$variable == 'log_k','value'] <- exp(parest[parest$variable == 'log_k','value'] )
parest$variable <- ifelse(parest$variable=='log_k',"k",paste(parest$variable))
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~variable, scales = "free_y")
ggsave(file = paste0(getwd(),"/plots/parplot_gam.png"),
plot = last_plot(), height = 6, width = 8, unit = 'in', dpi = 520)
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14),
axis.text = element_text(angle = 45))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~variable, scales = "free_y")
ggsave(file = paste0(getwd(),"/plots/parplot_gam.png"),
plot = last_plot(), height = 6, width = 8, unit = 'in', dpi = 520)
parest
rep0
KEY
head(DES)
KEY
head(KEY)
HEAD(DES)
head(cbind(KEY,DES))
rep0
unique(DES)
unique(KEY)
unique(KEY)[unique(DES)]
rep0
rep0 <- bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
# data.frame(c(rep(unique(
#   KEY
# ), 3), rep("ALL", 1)))
data.frame(c(rep(unique(KEY)[unique(DES)]
), 3), rep("ALL", 1)))
))
rep0 <- bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
# data.frame(c(rep(unique(
#   KEY
# ), 3), rep("ALL", 1)))
data.frame(c(rep(unique(KEY)[unique(DES)]
, 3), rep("ALL", 1)))
))
dat0 <- rep0 <- NULL ## later storage
nStrata <- length(unique(DES))
data <-
list(
Length_cm = all_data[,"Length_cm"],
Age = all_data[,"Age"],
DES = as.vector(DES),
nStrata = nStrata
)
parameters <-
list(
log_Linf = rep(log(70), nStrata),
log_k = rep(log(0.5), nStrata),
t0 = rep(0, nStrata),
log_Sigma = 0
)
# Now estimate everything
map <- NULL
model <- MakeADFun(data, parameters,  DLL="sptlvb",silent=T,map=map)
fit <- nlminb(
model$par,
model$fn,
model$gr,
control = list(
rel.tol = 1e-12,
eval.max = 100000,
iter.max = 10000
)
)
best <- model$env$last.par.best
rep <- sdreport(model)
dat0 <- c(dat0, model$report()$ypreds %>% data.frame()) ## each 6 cols is new sim
bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
# data.frame(c(rep(unique(
#   KEY
# ), 3), rep("ALL", 1)))
data.frame(c(rep(unique(KEY)[unique(DES)]
, 3), rep("ALL", 1)))
))
rep(unique(KEY)[unique(DES)]
, 3)
length(unique(KEY)[unique(DES)])
unique(KEY)
unique(DES)
rep0 <- bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
# data.frame(c(rep(unique(
#   KEY
# ), 3), rep("ALL", 1)))
data.frame(c(rep(unique(KEY)[unique(DES)+1]
, 3), rep("ALL", 1)))
))
rep0
unique(KEY)
dim(KEY)
load( paste0(getwd(),"/data/KEY_gam.rda")) ## KEY
dim(KEY)
length(KEY
)
head(all_data)
KEY[4]
KEY[unique(DES)]
unique(DES)
DES[4]
DES[99]
DES102
DES[1002]
DES[9999]
KEY[9999]
unique(KEY)
## now re-aggregate the data ----
## generate DES matrix of vectors and a KEY for later comparison
# DES <- KEY <-  matrix(NA, ncol = 1, nrow = nrow(all_data)) ## H1 is all zeros
# ## get region
# temp0 <- with(all_data, ifelse(Latitude_dd >= 49 & Year < 2005 ,0,
#                                ifelse(Latitude_dd >= 49 & Year >= 2005,1,
#                                       ifelse(Latitude_dd < 49 & Year < 2005,2,3))))
# ## get region and sex combos as factors
# DES <- as.numeric(factor(paste0(temp0,all_data[,'Sex'])))-1
# KEY <- paste0(c("North_Early","North_Late","South_Early","South_Late")[(temp0+1)],"_",all_data[,'Sex'])
apply(expand.grid(paste0(c("North_Early","North_Late","South_Early","South_Late"), c('F','M')), 1, paste, collapse=".")
)
, 1, paste, collapse=".")
## now re-aggregate the data ----
## generate DES matrix of vectors and a KEY for later comparison
# DES <- KEY <-  matrix(NA, ncol = 1, nrow = nrow(all_data)) ## H1 is all zeros
# ## get region
# temp0 <- with(all_data, ifelse(Latitude_dd >= 49 & Year < 2005 ,0,
#                                ifelse(Latitude_dd >= 49 & Year >= 2005,1,
#                                       ifelse(Latitude_dd < 49 & Year < 2005,2,3))))
# ## get region and sex combos as factors
# DES <- as.numeric(factor(paste0(temp0,all_data[,'Sex'])))-1
# KEY <- paste0(c("North_Early","North_Late","South_Early","South_Late")[(temp0+1)],"_",all_data[,'Sex'])
apply(expand.grid(c("North_Early","North_Late","South_Early","South_Late"), c('F','M'), 1, paste, collapse=".")
## now re-aggregate the data ----
## generate DES matrix of vectors and a KEY for later comparison
# DES <- KEY <-  matrix(NA, ncol = 1, nrow = nrow(all_data)) ## H1 is all zeros
# ## get region
# temp0 <- with(all_data, ifelse(Latitude_dd >= 49 & Year < 2005 ,0,
#                                ifelse(Latitude_dd >= 49 & Year >= 2005,1,
#                                       ifelse(Latitude_dd < 49 & Year < 2005,2,3))))
# ## get region and sex combos as factors
# DES <- as.numeric(factor(paste0(temp0,all_data[,'Sex'])))-1
# KEY <- paste0(c("North_Early","North_Late","South_Early","South_Late")[(temp0+1)],"_",all_data[,'Sex'])
apply(expand.grid(c("North_Early","North_Late","South_Early","South_Late"), c('F','M')), 1, paste, collapse=".")
## now re-aggregate the data ----
## generate DES matrix of vectors and a KEY for later comparison
# DES <- KEY <-  matrix(NA, ncol = 1, nrow = nrow(all_data)) ## H1 is all zeros
# ## get region
# temp0 <- with(all_data, ifelse(Latitude_dd >= 49 & Year < 2005 ,0,
#                                ifelse(Latitude_dd >= 49 & Year >= 2005,1,
#                                       ifelse(Latitude_dd < 49 & Year < 2005,2,3))))
# ## get region and sex combos as factors
# DES <- as.numeric(factor(paste0(temp0,all_data[,'Sex'])))-1
# KEY <- paste0(c("North_Early","North_Late","South_Early","South_Late")[(temp0+1)],"_",all_data[,'Sex'])
apply(expand.grid(c("North_Early","North_Late","South_Early","South_Late"), c('F','M')), 1,
paste, collapse="_")
## now re-aggregate the data ----
## generate DES matrix of vectors and a KEY for later comparison
# DES <- KEY <-  matrix(NA, ncol = 1, nrow = nrow(all_data)) ## H1 is all zeros
# ## get region
# temp0 <- with(all_data, ifelse(Latitude_dd >= 49 & Year < 2005 ,0,
#                                ifelse(Latitude_dd >= 49 & Year >= 2005,1,
#                                       ifelse(Latitude_dd < 49 & Year < 2005,2,3))))
# ## get region and sex combos as factors
# DES <- as.numeric(factor(paste0(temp0,all_data[,'Sex'])))-1
# KEY <- paste0(c("North_Early","North_Late","South_Early","South_Late")[(temp0+1)],"_",all_data[,'Sex'])
keybase <- apply(expand.grid(c("North_Early","North_Late","South_Early","South_Late"), c('F','M')), 1,
paste, collapse="_")
rep0 <- bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
# data.frame(c(rep(unique(
#   KEY
# ), 3), rep("ALL", 1)))
data.frame(c(rep(keybase
, 3), rep("ALL", 1)))
))
rep0
dat0 <- rep0 <- NULL ## later storage
nStrata <- length(unique(DES))
data <-
list(
Length_cm = all_data[,"Length_cm"],
Age = all_data[,"Age"],
DES = as.vector(DES),
nStrata = nStrata
)
parameters <-
list(
log_Linf = rep(log(70), nStrata),
log_k = rep(log(0.5), nStrata),
t0 = rep(0, nStrata),
log_Sigma = 0
)
# Now estimate everything
map <- NULL
model <- MakeADFun(data, parameters,  DLL="sptlvb",silent=T,map=map)
fit <- nlminb(
model$par,
model$fn,
model$gr,
control = list(
rel.tol = 1e-12,
eval.max = 100000,
iter.max = 10000
)
)
best <- model$env$last.par.best
rep <- sdreport(model)
dat0 <- c(dat0, model$report()$ypreds %>% data.frame()) ## each 6 cols is new sim
rep0 <- bind_rows(rep0,
bind_cols(
data.frame(names(rep$value)),
data.frame(rep$value),
data.frame(rep$sd),
# data.frame(c(rep(unique(
#   KEY
# ), 3), rep("ALL", 1)))
data.frame(c(rep(keybase
, 3), rep("ALL", 1)))
))
rep0
## reformat outputs ----
names(rep0) <- c('variable', 'value','sd', 'ID')
rep0 <- rep0 %>% mutate(
st =sub('_([^_]*)$', '',  ID),
Sex = sub(".*_ *(._?)", "\\1", ID)
) %>% select(-ID)
rep0
write.csv(rep0, paste0(getwd(),"/results/parEst_gam_",Sys.Date(),'.csv'),row.names = F)
## parest by sex and region
parest <- read.csv("C:/Users/mkapur/Dropbox/UW/sab-growth/results/parEst_gam_2018-12-11.csv") %>%
filter(variable != "Sigma")
## exponentiate logk
parest[parest$variable == 'log_k','value'] <- exp(parest[parest$variable == 'log_k','value'] )
parest$variable <- ifelse(parest$variable=='log_k',"k",paste(parest$variable))
ggplot(parest, aes(x = st, y = value, col = Sex))+
theme_bw() +
theme(panel.grid = element_blank(),
legend.position = c(0.25,0.9),
legend.text = element_text(size = 14),
strip.text = element_text(size=14),
axis.text = element_text(angle = 45))+
scale_color_manual(values = c("#d8b365","#5ab4ac"))+
geom_point() +
geom_errorbar(aes(ymin = value - 1.96*sd, ymax = value + 1.96*sd)) +
labs(x = 'Spatial Stratum', y = "") +
facet_wrap(~variable, scales = "free_y")
ggsave(file = paste0(getwd(),"/plots/parplot_gam.png"),
plot = last_plot(), height = 6, width = 8, unit = 'in', dpi = 520)
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
## source from gist
source(paste0(getwd(),"/Deriv.R"))
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
## here I iterate sex as a sanity check but it is actually not necessary -- results will be the same since sex is a covariate
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
idx <- 1
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.025, 0.975), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[idx]] <- sort(c(unique(round(vals)))) ## get rounded unique
# cat(idx)
idx <- idx+1
}
}
png( file = paste0(getwd(),"/plots/gam_smooths.png"), height = 6, width = 8, units = 'in', res = 500)
layout(matrix(1:4, ncol = 2))
plot(mod,  select  =1,  scheme
=2,  lwd  =2, main = 'Year Smoother', cex.axis = 2)
plot(mod,  select  =2,  scheme  =2,
lwd  =2, main = 'Latitude Smoother', cex.axis = 2)
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
abline(v = breaksdf[[2]], col = 'red')
dev.off()
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
m2.d
Deriv(mod, newdata = newD)
# save(mod, file = paste0(getwd(),'/spatial_gam.rda'))
load(paste0(getwd(),'/spatial_gam.rda'))
## here I iterate sex as a sanity check but it is actually not necessary -- results will be the same since sex is a covariate
# breaksdf <- data.frame(Sex = NA, YrBreaks = NA, LatBreaks = NA)
breaksdf <- list()
idx <- 1
for(s in 1:2){
# breaksdf[s,'Sex'] = c("M","F")[s]
for(t in 1:2){
newD <- data.frame(Age = mean(seq(0,94,length = 100)), ## use mean age?
Sex = c("M","F")[s],
Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100))
dr <- Deriv(mod,newdata = newD)
confint.Deriv(dr)
Term <- c("Year","Latitude_dd")[t]
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
# crit.eval = mean(m2.d[[Term]]$deriv) ## use mean
crit.eval = quantile(probs = c(0.025, 0.975), x=  m2.d[[Term]]$deriv) ## use tails
## identify where CI does NOT include some crit value (return NA where it does)
m2.dsig <- signifD(m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
m2.dci[[Term]]$upper,
m2.dci[[Term]]$lower, eval = crit.eval)
pix <- c(which(!is.na(m2.dsig$incr)), which(!is.na(m2.dsig$decr)))
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[idx]] <- sort(c(unique(round(vals)))) ## get rounded unique
# cat(idx)
idx <- idx+1
}
}
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
png( file = paste0(getwd(),"/plots/gam_smooths.png"), height = 6, width = 8, units = 'in', res = 500)
layout(matrix(1:4, ncol = 2))
plot(mod,  select  =1,  scheme
=2,  lwd  =2, main = 'Year Smoother', cex.axis = 2)
plot(mod,  select  =2,  scheme  =2,
lwd  =2, main = 'Latitude Smoother', cex.axis = 2)
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
abline(v = breaksdf[[2]], col = 'red')
dev.off()
plot(mod,  select  =2,  scheme  =2, xlim = c(35,60),
lwd  =2, main = 'Latitude Smoother', cex.axis = 2)
png( file = paste0(getwd(),"/plots/gam_smooths.png"), height = 6, width = 8, units = 'in', res = 500)
layout(matrix(1:4, ncol = 2))
plot(mod,  select  =1,  scheme
=2,  lwd  =2, main = 'Year Smoother', cex.axis = 2)
plot(mod,  select  =2,  scheme  =2, xlim = c(35,60),
lwd  =2, main = 'Latitude Smoother', cex.axis = 2)
plot.Deriv(m2.d, term = 'Year', cex.axis = 2, main = 'derivative of year')
abline(v = breaksdf[[1]], col = 'red')
plot.Deriv(m2.d, term = 'Latitude_dd',
cex.axis = 2, xlim = c(35,60), main = 'derivative of latitude')
abline(v = breaksdf[[2]], col = 'red')
dev.off()
head(all_data)
all_data %>% group_by(Year,REG) %>% summarise(N = n())
