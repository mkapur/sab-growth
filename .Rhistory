axis.title =element_blank(),
legend.position = c(0.1,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12)) +
# geom_hline(yintercept = c(36,50),lwd = 1.1, linetype = 'dashed', col = 'red') +
# geom_vline(xintercept =  -130, lwd = 1.1, linetype = 'dashed', col = 'red') +
## ecosystem break
# geom_vline(xintercept =  -145, lwd = 1.1, linetype = 'dashed', col = 'blue') +
geom_rect(fill = 'black', aes(xmin = -180, xmax = -130.1,
ymin = 30, ymax = 49.9)) +
geom_point(data = sample_n(subset(ypreds0, Sex == 'F'),5000),
aes(x = Longitude_dd, y = Latitude_dd,
fill = Residual),
shape = 21, alpha = 0.7, size = 10) +
scale_fill_viridis_c(guide = "legend", limits = c(-20,20)) +
# scale_fill_gradientn(colors = brewer.pal(9,'Reds'))+
# scale_size_identity(guide = "legend", limits = c(-10,10)) +
# scale_size_manual(guide = 'none')+
labs(fill = paste0("Length (cm)"),
title = "Residuals for Coastwide Von Bertalanffy Model (female sablefish)")
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap() +
scale_x_continuous(expand = c(0,0), limits = c(-180,-110), breaks = seq(-180,-120,10), labels = paste(seq(-180,-120,10), "°W")) +
scale_y_continuous(expand = c(0,0), limits = c(30,75), breaks = seq(30,75,10), labels =  paste(seq(30,75,10), "°N"))  +
theme_black(base_size = 20) +
theme(panel.grid.major = element_blank(),
axis.title =element_blank(),
legend.position = c(0.1,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12)) +
# geom_hline(yintercept = c(36,50),lwd = 1.1, linetype = 'dashed', col = 'red') +
# geom_vline(xintercept =  -130, lwd = 1.1, linetype = 'dashed', col = 'red') +
## ecosystem break
# geom_vline(xintercept =  -145, lwd = 1.1, linetype = 'dashed', col = 'blue') +
geom_rect(fill = 'black', aes(xmin = -180, xmax = -130.1,
ymin = 30, ymax = 49.9)) +
geom_point(data = sample_n(subset(ypreds0, Sex == 'F'),5000),
aes(x = Longitude_dd, y = Latitude_dd,
fill = Residual),
shape = 21, alpha = 0.7, size = 10) +
scale_fill_viridis_c(guide = "legend", limits = c(-20,20)) +
# scale_fill_gradientn(colors = brewer.pal(9,'Reds'))+
# scale_size_identity(guide = "legend", limits = c(-10,10)) +
# scale_size_manual(guide = 'none')+
labs(fill = paste0("Length Residual(cm)"),
title = "Residuals for Coastwide Von Bertalanffy Model (female sablefish)")
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap() +
scale_x_continuous(expand = c(0,0), limits = c(-180,-110), breaks = seq(-180,-120,10), labels = paste(seq(-180,-120,10), "°W")) +
scale_y_continuous(expand = c(0,0), limits = c(30,75), breaks = seq(30,75,10), labels =  paste(seq(30,75,10), "°N"))  +
theme_black(base_size = 20) +
theme(panel.grid.major = element_blank(),
axis.title =element_blank(),
legend.position = c(0.2,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12)) +
# geom_hline(yintercept = c(36,50),lwd = 1.1, linetype = 'dashed', col = 'red') +
# geom_vline(xintercept =  -130, lwd = 1.1, linetype = 'dashed', col = 'red') +
## ecosystem break
# geom_vline(xintercept =  -145, lwd = 1.1, linetype = 'dashed', col = 'blue') +
geom_rect(fill = 'black', aes(xmin = -180, xmax = -130.1,
ymin = 30, ymax = 49.9)) +
geom_point(data = sample_n(subset(ypreds0, Sex == 'F'),5000),
aes(x = Longitude_dd, y = Latitude_dd,
fill = Residual),
shape = 21, alpha = 0.7, size = 10) +
scale_fill_viridis_c(guide = "legend", limits = c(-20,20)) +
# scale_fill_gradientn(colors = brewer.pal(9,'Reds'))+
# scale_size_identity(guide = "legend", limits = c(-10,10)) +
# scale_size_manual(guide = 'none')+
labs(fill = paste0("Length Residual(cm)"),
title = "Residuals for Coastwide Von Bertalanffy Model (female sablefish)")
ggsave(plot = last_plot(),
file = paste0("./figures/BLACK_resids.png"),
width = 10, height = 10, units = 'in', dpi = 480)
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap() +
scale_x_continuous(expand = c(0,0), limits = c(-180,-110), breaks = seq(-180,-120,10), labels = paste(seq(-180,-120,10), "°W")) +
scale_y_continuous(expand = c(0,0), limits = c(30,75), breaks = seq(30,75,10), labels =  paste(seq(30,75,10), "°N"))  +
theme_black(base_size = 20) +
theme(panel.grid.major = element_blank(),
axis.title =element_blank(),
legend.position = c(0.2,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12)) +
# geom_hline(yintercept = c(36,50),lwd = 1.1, linetype = 'dashed', col = 'red') +
# geom_vline(xintercept =  -130, lwd = 1.1, linetype = 'dashed', col = 'red') +
## ecosystem break
# geom_vline(xintercept =  -145, lwd = 1.1, linetype = 'dashed', col = 'blue') +
geom_rect(fill = 'black', aes(xmin = -180, xmax = -130.1,
ymin = 30, ymax = 49.9)) +
geom_point(data = sample_n(subset(ypreds0, Sex == 'F'),5000),
aes(x = Longitude_dd, y = Latitude_dd,
fill = Residual),
shape = 21, alpha = 0.7, size = 10) +
scale_fill_viridis_c(guide = "legend", limits = c(-20,20)) +
# scale_fill_gradientn(colors = brewer.pal(9,'Reds'))+
# scale_size_identity(guide = "legend", limits = c(-10,10)) +
# scale_size_manual(guide = 'none')+
labs(fill = paste0("Length Residual(cm)"),
title = "Residuals for Coastwide Von Bertalanffy Model",
subtitle = "female sablefish")
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap() +
scale_x_continuous(expand = c(0,0), limits = c(-180,-110), breaks = seq(-180,-120,10), labels = paste(seq(-180,-120,10), "°W")) +
scale_y_continuous(expand = c(0,0), limits = c(30,75), breaks = seq(30,75,10), labels =  paste(seq(30,75,10), "°N"))  +
theme_black(base_size = 18) +
theme(panel.grid.major = element_blank(),
axis.title =element_blank(),
legend.position = c(0.2,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12)) +
geom_rect(fill = 'black', aes(xmin = -180, xmax = -130.1,
ymin = 30, ymax = 49.9)) +
geom_point(data = sample_n(subset(ypreds0, Sex == 'F'),5000),
aes(x = Longitude_dd, y = Latitude_dd,
fill = Residual),
shape = 21, alpha = 0.7, size = 10) +
scale_fill_viridis_c(guide = "legend", limits = c(-20,20)) +
# scale_fill_gradientn(colors = brewer.pal(9,'Reds'))+
# scale_size_identity(guide = "legend", limits = c(-10,10)) +
# scale_size_manual(guide = 'none')+
labs(fill = paste0("Length Residual(cm)"),
title = "Residuals for Coastwide Von Bertalanffy Model",
subtitle = "female sablefish")
ggsave(plot = last_plot(),
file = paste0("./figures/BLACK_resids.png"),
width = 10, height = 10, units = 'in', dpi = 480)
require(ggplot2)
require(kaputils)
require(dplyr)
source("C:/Users/mkapur/Dropbox/kaputils/R/theme_black.R")
## black neatplot from sab with faceted curves
ypreds <- read.csv(paste0("C:/Users/mkapur/Dropbox/UW/sab-growth/GAM_output/SAB_predicts_2019-10-04_phase2.csv"))
## black neatplot from sab with faceted curves
ypreds <- read.csv(paste0("C:/Users/maia kapur/Dropbox/UW/sab-growth/GAM_output/SAB_predicts_2019-10-04_phase2.csv"))
ypreds$gamREG <- paste0('Region ',ypreds$gamREG)
levels(ypreds$Sex) <- c('Females','Males')
levels(ypreds$Period) <- c('pre-2010','2010-Present','All Years')
for(i in 1:nrow(ypreds)){
ypreds$Period[i] <-  ifelse(length(grep('pool', ypreds$cREG[i])) == 1,
'All Years', paste(ypreds$Period[i]))
}
fd_summary_gamREG <- ypreds %>%
filter(Age < 31) %>%
group_by(Age, Sex, gamREG,Period) %>%
dplyr::summarise(meanL = mean(Length_cm), sdmeanL = sd(Length_cm), meanPred = mean(Predicted))
ggplot(fd_summary_gamREG, aes(x = Age, col = gamREG, group = gamREG)) +
theme_black(base_size = 20) +
theme(panel.grid = element_blank(),
legend.position = 'right') +
scale_alpha(guide = 'none') +
scale_y_continuous(limits = c(0,110)) +
scale_color_brewer(palette =  'Accent')+
geom_point( aes(y = meanL)) +
geom_line(aes(y = meanPred, col = gamREG), lwd = 1.1)+
labs(y = 'Length (cm)', x= 'Age (years)', col = "GAM-Detected Region") +
# scale_linetype_manual(values=c("solid", "dashed", "dotted"))+
facet_wrap(~Sex +Period, ncol = 4)
#
ggsave(plot  = last_plot(),
file = "C:/Users/mkapur/Dropbox/UW/sab-growth/figures/ICES_black_figs/VBGF_meanL_periodXregion_black.png",
height = 8, width = 16, unit = 'in', dpi = 520)
#
ggsave(plot  = last_plot(),
file = "C:/Users/maia kapur/Dropbox/UW/sab-growth/figures/ICES_black_figs/VBGF_meanL_periodXregion_black.png",
height = 8, width = 16, unit = 'in', dpi = 520)
require(ggplot2)
require(kaputils)
require(dplyr)
source("C:/Users/mkapur/Dropbox/kaputils/R/theme_black.R")
usa <- map_data("world")
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap()
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap() +
scale_x_continuous(expand = c(0,0), limits = c(-180,-110), breaks = seq(-180,-120,10), labels = paste(seq(-180,-120,10), "Â°W")) +
scale_y_continuous(expand = c(0,0), limits = c(30,75), breaks = seq(30,75,10), labels =  paste(seq(30,75,10), "Â°N"))  +
theme_black(base_size = 18) +
theme(panel.grid.major = element_blank(),
axis.title =element_blank(),
legend.position = c(0.2,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12))
usa <- map_data("world")
ggplot() +
geom_polygon(data = usa, aes(x = long, y = lat, group = group), fill = 'grey66') +
coord_quickmap() +
scale_x_continuous(expand = c(0,0), limits = c(-180,-110), breaks = seq(-180,-120,10), labels = paste(seq(-180,-120,10), "°W")) +
scale_y_continuous(expand = c(0,0), limits = c(30,75), breaks = seq(30,75,10), labels =  paste(seq(30,75,10), "°N"))  +
theme_black(base_size = 18) +
theme(panel.grid.major = element_blank(),
axis.title =element_blank(),
legend.position = c(0.2,0.2),
legend.key.size = unit(0.75, "cm"),
legend.text = element_text(size = 12))
ggsave(plot = last_plot(),
file = paste0("./figures/ICES_black_figs/map_black.png"),
width = 10, height = 10, units = 'in', dpi = 520)
## Updated GAM method for SAB
## kapurm spring 2019
## source from gist
rm(list = ls())
require(mgcv);require(dplyr);require(ggplot2); require(TMB); library(reshape2)
library(gridExtra); library(grid); library(lattice)
compname <- c("Maia Kapur","mkapur")[2]
source(paste0(getwd(),"/functions/Deriv.R")); source("./functions/getGR.R")
load(paste0("./input_data/gam_data_sab_0415.rda")) ## full_data -- made using gam_dataprep NOT 15k subsample
head(full_data)
AA = 4
SS = "F"
dat <- full_data %>% filter( Age == AA  & Sex == SS)
mod <- gam(Length_cm ~ s(Year, bs = "cc") + s(Latitude_dd) + s(Longitude_dd),data = dat)
# png(paste0("./figures/sab_gam_diagnostics_",AA,SS,".png"), width = 7, height = 5, units = 'in', res = 420)
layout(matrix(1:4, ncol = 2))
## get & eval derivatives ----
pdat <- dat
pdat <- dat
pTerm <- predict(mod, newdata = pdat, type = "terms", se.fit = TRUE) ## predict on original data
p2 <- predict(mod, newdata = pdat) ## raw predicts
pdat <- transform(pdat, predLen = p2, se2_lat = pTerm$se.fit[,2],se2_lon = pTerm$se.fit[,3], se2_yr = pTerm$se.fit[,1])
df.res <- df.residual(mod)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
## variances are additive just FYI
pdat <- transform(pdat,
upper = predLen + (crit.t * (se2_lat+se2_lon+se2_yr)),
lower = predLen - (crit.t * (se2_lat+se2_lon+se2_yr)))
breaksdf <- list()
Terms <- c("Year","Latitude_dd","Longitude_dd")
## predict over parameter space
for(t in 1:length(Terms)){
Term <- Terms[t]
newD <- data.frame( Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100)) ## whatever isn't modeled will just get ignored
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
crit.eval = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$deriv) ## use tails
crit.eval.se = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$se.deriv) ## use tails
## identify where mean crosses zero or falls out of bounds (NAs where it does)
m2.dsig.zeros <- signifMK(x = m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
upper = m2.dci[[Term]]$upper,
lower = m2.dci[[Term]]$lower,
crit.eval = crit.eval,
eval = 0)
pix <- !is.na(m2.dsig.zeros)
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[t]] <- sort(c(unique(round(vals)))) ## get rounded unique
## fill NAs in bdf for binding
for(i in 1:length(breaksdf)){
if (length(breaksdf[[i]]) == 0){ ## fill NA for empty
breaksdf[[i]] <- NA
}
}## end breaksdf
} ## end terms
breaksdf
## Fit GAMS to ID breakpoints ----
for(AA in c(4,6,30)){ ## ages to define breakpoints; often roughly correspond with L1/L2
for(SS in c("F","M")){
dat <- full_data %>% filter( Age == AA  & Sex == SS)
mod <- gam(Length_cm ~ s(Year, bs = "cc") + s(Latitude_dd) + s(Longitude_dd),data = dat)
# png(paste0("./figures/sab_gam_diagnostics_",AA,SS,".png"), width = 7, height = 5, units = 'in', res = 420)
layout(matrix(1:4, ncol = 2))
gam.check(mod)
# graphics.off()
## get & eval derivatives ----
pdat <- dat
pTerm <- predict(mod, newdata = pdat, type = "terms", se.fit = TRUE) ## predict on original data
p2 <- predict(mod, newdata = pdat) ## raw predicts
pdat <- transform(pdat, predLen = p2, se2_lat = pTerm$se.fit[,2],se2_lon = pTerm$se.fit[,3], se2_yr = pTerm$se.fit[,1])
df.res <- df.residual(mod)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
## variances are additive just FYI
pdat <- transform(pdat,
upper = predLen + (crit.t * (se2_lat+se2_lon+se2_yr)),
lower = predLen - (crit.t * (se2_lat+se2_lon+se2_yr)))
breaksdf <- list()
Terms <- c("Year","Latitude_dd","Longitude_dd")
## predict over parameter space
for(t in 1:length(Terms)){
Term <- Terms[t]
newD <- data.frame( Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100)) ## whatever isn't modeled will just get ignored
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
crit.eval = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$deriv) ## use tails
crit.eval.se = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$se.deriv) ## use tails
## identify where mean crosses zero or falls out of bounds (NAs where it does)
m2.dsig.zeros <- signifMK(x = m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
upper = m2.dci[[Term]]$upper,
lower = m2.dci[[Term]]$lower,
crit.eval = crit.eval,
eval = 0)
pix <- !is.na(m2.dsig.zeros)
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[t]] <- sort(c(unique(round(vals)))) ## get rounded unique
## fill NAs in bdf for binding
for(i in 1:length(breaksdf)){
if (length(breaksdf[[i]]) == 0){ ## fill NA for empty
breaksdf[[i]] <- NA
}
}## end breaksdf
} ## end terms
} ## end sexes
} ## end key ages
breaksdf
for(AA in c(4,6,30)){ ## ages to define breakpoints; often roughly correspond with L1/L2
for(SS in c("F","M")){
dat <- full_data %>% filter( Age == AA  & Sex == SS)
mod <- gam(Length_cm ~ s(Year, bs = "cc") + s(Latitude_dd) + s(Longitude_dd),data = dat)
# png(paste0("./figures/sab_gam_diagnostics_",AA,SS,".png"), width = 7, height = 5, units = 'in', res = 420)
layout(matrix(1:4, ncol = 2))
gam.check(mod)
# graphics.off()
## get & eval derivatives ----
pdat <- dat
pTerm <- predict(mod, newdata = pdat, type = "terms", se.fit = TRUE) ## predict on original data
p2 <- predict(mod, newdata = pdat) ## raw predicts
pdat <- transform(pdat, predLen = p2, se2_lat = pTerm$se.fit[,2],se2_lon = pTerm$se.fit[,3], se2_yr = pTerm$se.fit[,1])
df.res <- df.residual(mod)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
## variances are additive just FYI
pdat <- transform(pdat,
upper = predLen + (crit.t * (se2_lat+se2_lon+se2_yr)),
lower = predLen - (crit.t * (se2_lat+se2_lon+se2_yr)))
Terms <- c("Year","Latitude_dd","Longitude_dd")
## predict over parameter space
for(t in 1:length(Terms)){
Term <- Terms[t]
newD <- data.frame( Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100)) ## whatever isn't modeled will just get ignored
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
crit.eval = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$deriv) ## use tails
crit.eval.se = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$se.deriv) ## use tails
## identify where mean crosses zero or falls out of bounds (NAs where it does)
m2.dsig.zeros <- signifMK(x = m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
upper = m2.dci[[Term]]$upper,
lower = m2.dci[[Term]]$lower,
crit.eval = crit.eval,
eval = 0)
pix <- !is.na(m2.dsig.zeros)
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[idx]] <- sort(c(unique(round(vals)))) ## get rounded unique
idx = idx+1
## fill NAs in bdf for binding
for(i in 1:length(breaksdf)){
if (length(breaksdf[[i]]) == 0){ ## fill NA for empty
breaksdf[[i]] <- NA
}
}## end breaksdf
} ## end terms
} ## end sexes
} ## end key ages
## Fit GAMS to ID breakpoints ----
breaksdf <- list(); idx = 1## storage for breakpoints
for(AA in c(4)){ ## ages to define breakpoints; often roughly correspond with L1/L2
for(SS in c("F","M")){
dat <- full_data %>% filter( Age == AA  & Sex == SS)
mod <- gam(Length_cm ~ s(Year, bs = "cc") + s(Latitude_dd) + s(Longitude_dd),data = dat)
# png(paste0("./figures/sab_gam_diagnostics_",AA,SS,".png"), width = 7, height = 5, units = 'in', res = 420)
layout(matrix(1:4, ncol = 2))
gam.check(mod)
# graphics.off()
## get & eval derivatives ----
pdat <- dat
pTerm <- predict(mod, newdata = pdat, type = "terms", se.fit = TRUE) ## predict on original data
p2 <- predict(mod, newdata = pdat) ## raw predicts
pdat <- transform(pdat, predLen = p2, se2_lat = pTerm$se.fit[,2],se2_lon = pTerm$se.fit[,3], se2_yr = pTerm$se.fit[,1])
df.res <- df.residual(mod)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
## variances are additive just FYI
pdat <- transform(pdat,
upper = predLen + (crit.t * (se2_lat+se2_lon+se2_yr)),
lower = predLen - (crit.t * (se2_lat+se2_lon+se2_yr)))
Terms <- c("Year","Latitude_dd","Longitude_dd")
## predict over parameter space
for(t in 1:length(Terms)){
Term <- Terms[t]
newD <- data.frame( Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100)) ## whatever isn't modeled will just get ignored
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
crit.eval = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$deriv) ## use tails
crit.eval.se = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$se.deriv) ## use tails
## identify where mean crosses zero or falls out of bounds (NAs where it does)
m2.dsig.zeros <- signifMK(x = m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
upper = m2.dci[[Term]]$upper,
lower = m2.dci[[Term]]$lower,
crit.eval = crit.eval,
eval = 0)
pix <- !is.na(m2.dsig.zeros)
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[idx]] <- sort(c(unique(round(vals)))) ## get rounded unique
idx = idx+1
## fill NAs in bdf for binding
for(i in 1:length(breaksdf)){
if (length(breaksdf[[i]]) == 0){ ## fill NA for empty
breaksdf[[i]] <- NA
}
}## end breaksdf
} ## end terms
} ## end sexes
} ## end key ages
breaksdf
## Fit GAMS to ID breakpoints ----
breaksdf <- list(); idx = 1## storage for breakpoints;
breaks_df <- data.frame(Age = NA, Sex = NA, Year = NA, Lat = NA, Lon = NA)
for(AA in c(4,6,30)){ ## ages to define breakpoints; often roughly correspond with L1/L2
for(SS in c("F","M")){
dat <- full_data %>% filter( Age == AA  & Sex == SS)
mod <- gam(Length_cm ~ s(Year, bs = "cc") + s(Latitude_dd) + s(Longitude_dd),data = dat)
# png(paste0("./figures/sab_gam_diagnostics_",AA,SS,".png"), width = 7, height = 5, units = 'in', res = 420)
layout(matrix(1:4, ncol = 2))
gam.check(mod)
# graphics.off()
## get & eval derivatives ----
pdat <- dat
pTerm <- predict(mod, newdata = pdat, type = "terms", se.fit = TRUE) ## predict on original data
p2 <- predict(mod, newdata = pdat) ## raw predicts
pdat <- transform(pdat, predLen = p2, se2_lat = pTerm$se.fit[,2],se2_lon = pTerm$se.fit[,3], se2_yr = pTerm$se.fit[,1])
df.res <- df.residual(mod)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
## variances are additive just FYI
pdat <- transform(pdat,
upper = predLen + (crit.t * (se2_lat+se2_lon+se2_yr)),
lower = predLen - (crit.t * (se2_lat+se2_lon+se2_yr)))
Terms <- c("Year","Latitude_dd","Longitude_dd")
## predict over parameter space
for(t in 1:length(Terms)){
Term <- Terms[t]
newD <- data.frame( Year = seq(1981,2017,length = 100),
Longitude_dd = seq(-186,-116, length = 100),
Latitude_dd = seq(0,64,length = 100)) ## whatever isn't modeled will just get ignored
m2.d <- Deriv(mod, newdata = newD)
m2.dci <- confint(m2.d, term = Term)
crit.eval = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$deriv) ## use tails
crit.eval.se = quantile(probs = c(0.025, 0.975), x =  m2.d[[Term]]$se.deriv) ## use tails
## identify where mean crosses zero or falls out of bounds (NAs where it does)
m2.dsig.zeros <- signifMK(x = m2.d$eval[[Term]],
d = m2.d[[Term]]$deriv,
upper = m2.dci[[Term]]$upper,
lower = m2.dci[[Term]]$lower,
crit.eval = crit.eval,
eval = 0)
pix <- !is.na(m2.dsig.zeros)
vals <- m2.d$eval[[Term]][pix] ## what test vals did these correspond to
breaksdf[[idx]] <- sort(c(unique(round(vals)))) ## get rounded unique
idx = idx+1
## fill NAs in bdf for binding
for(i in 1:length(breaksdf)){
if (length(breaksdf[[i]]) == 0){ ## fill NA for empty
breaksdf[[i]] <- NA
}
}## end breaksdf
} ## end terms
} ## end sexes
} ## end key ages
breaksdf
## reformat breaks DF for interpredation
breaks_df$Age <- rep(c(4,6,30),2)
breaks_df
breaks_df$Age <- rep(c(4,6,30),2)
## reformat breaks DF for interpredation
breaks_df$Age <- cbind(rep(c(4,6,30),2))
## reformat breaks DF for interpredation
breaks_df <- data.frame(Age = rep(c(4,6,30),2), Sex = NA, Year = NA, Lat = NA, Lon = NA)
breaks_df
## reformat breaks DF for interpredation
breaks_df <- data.frame(Age = rep(c(4,6,30),2), Sex = c(rep("F",3),rep("M",3)), Year = NA, Lat = NA, Lon = NA)
BREAKSDF
breaksdf
seq(1,length(breaksdf),3)
breaksdf[[seq(1,length(breaksdf),3)]]
breaksdf[[c(seq(1,length(breaksdf),3))]]
vec <- seq(1,length(breaksdf),3)
vec
paste(vec,",")
breaks_df$Year <- breaksdf[[vec]]
seq(1,length(breaksdf),3)
vec <- c(seq(1,length(breaksdf),3))
breaksdf[[vec]]
lapply(breaksdf, `[`, vec)
sapply(breaksdf, `[`, vec)
vec
breaksdf
sapply(breaksdf, `[`, vec)
lapply(breaksdf, `[[`, vec)
vec <- c(seq(1,length(breaksdf),3))
for(i in 1:length(vec)){
breaks_df$Year[i] <- breaksdf[[vec[i]]]
}
breaks_df
for(i in 1:length(vec)){
breaks_df$Year[i] <- breaksdf[[vec[i]]]
breaks_df$Lat[i] <- breaksdf[[vec[i]+1]]
breaks_df$Lon[i] <- breaksdf[[vec[i]+2]]
}
breaks_df
